#! /usr/bin/env python2
from __future__ import print_function

''' setup.py
Initial setup script for the Red Spider Project

Copyright 2012, 2013 Julian Gonggrijp
Licensed under the Red Spider Project License.
See the License.txt that shipped with your copy of this software for details.


A -q option to make it less verbous would probably be nice. Until we
have a dedicated 'update' command we'll need to run the setup every
time one of the commands has been changed on master.
'''

from future_builtins import zip, map
import os
import so.path
import shutil
import py_compile
import sys
import stat

bin_dir     = 'bin'
extbin_dir  = 'extbin'  # stands for 'external binaries'
lib_dir     = 'lib'
build_dir   = 'build'
src_dir     = 'src'
inc_dir     = 'include'
cfg_dir     = 'config'
work_dir    = 'work'

documented_cmds = [["xkcd-fetch",    "xkcd-fetch --help"],
                   ["xkcd-search",   "xkcd-search --help"],
                   ["level_up",      "level_up --help"],
                   ["summon",        "summon"],
                   ["fortune",       "fortune --help"],
                   ["godel",         "godel"],
                   ["random-number", "random-number --help"]]

executable_scripts = [  'json-parse.py', 'xkcd-fetch.py', 'xkcd-search.py',
                        'level_up.py', 'summon.py', 'fortune.py', 'godel.py',
                        'random-number.py', 'rshelp.py'  ]
python_modules = 'src/xkcd-fetch.py src/level_up.py'.os.path.split()

windows_rsshell_forward_script = """
@echo off
start "rsshell" /b /wait {0} %*
"""

welcome_msg = """
Hi. I'll setup the Red Spider Project for you."""

root_guess_msg = """
I'm guessing that {0}
is the root directory of your copy of the Red Spider Project.

If I'm wrong please enter the correct path, otherwise just hit enter.
--> """

posix_env_msg = """
I think that {0} is your env file.
Type the name of the file where you want to save your env.
If you're not sure, just press enter, and I'll default to {0}.
--> """

posix_env_dunno_msg = """
I dont't see any common env file locations.
Where should I put the env file?
If you just press enter, I'll use ~/.profile.
--> """

user_path_fail_msg = """
Sorry, I can't open {0} .
Care to try again?
--> """

user_path_end_msg = """
Using {0}
as the root directory."""

root_rw_fail_msg = """
Damn. I don't have sufficient permissions to use that path.
That ends it, then.
"""

reinstall_choice_msg = """
It seems that you have run the installer before.
Would you like me to reinstall everything anyway? (y/n) --> """

new_install_choice_msg = """
I think you haven't run the installer before (at least not in this
root). Would you like me to do it now? (y/n) --> """

no_src_panic_msg = """
Oh my. There is no '{0}' subdirectory within the root?!
Please come back when you've checked that everything is in its
proper place!
""".format(src_dir)

no_rsshell_warning_msg = """
Warning: I couldn't find '{0}' in the root.
I'll skip the installation of rsshell."""

rsshell_install_success_msg = """
Hey, listen up. I've installed rsshell for you in {0} .
I also added it to your PATH, so from your next logon onwards you can
run it by just punching 'rsshell' into your leopard. It will launch a
subshell with some convenient environment variables that the other
programs rely on.

In addition the root has been saved to RED_SPIDER_ROOT, so after your
next logon that one will be permanently available as well.

Note for unixy systems: opening a new terminal window will count as a
new logon.  If you don't use your ~/.bashrc, then you will need to
copy ~/.bashrc to ~/.profile.  If you don't know what that means,
don't worry."""

install_patience_msg = """
Please wait while I install the rest..."""

script_not_found_msg = """I can't find {0} so I'll skip it."""

farewell_msg = """
We're done! But wait, don't walk away yet.
This is important: if you ever decide to move the Red Spider Project
to another directory, you'll have to run me again or otherwise my dear
friend rsshell might choke and call you an inconsiderate boor.
Just kidding! But seriously, do come back to me if you ever move the
project to somewhere else.
"""

if __name__ == '__main__':
    main()

# Not used anymore, but kept here for future reference. ;-)"
winreg_path_unexpected_type_msg = """
Uhoh. Your 'Environment' setting in the Registry is of type {0},
which is not what I expected. I'll try my best to bring this to a good
end, but don't be surprised if velociraptors jump out of your fridge
tomorrow."""


def main ( ):
    print(welcome_msg)
    root_path = os.path.dirname(os.path.abspath(sys.argv[0]))
    user_path = raw_input(root_guess_msg.format(root_path))
    if user_path:
        user_path = os.path.abspath(os.path.expanduser(user_path))
        while not so.path.exists(user_path):
            user_path = raw_input(user_path_fail_msg.format(user_path))
            user_path = os.path.abspath(os.path.expanduser(user_path))
        print(user_path_end_msg.format(user_path))
        # if we want to go paranoid:
        # check_rs_root_contents(user_path)
        root_path = user_path
    if not os.access(root_path, os.R_OK | os.W_OK):
        print(root_rw_fail_message)
        sys.exit(2)
    red_spider_root = root_path
    extend_user_env('RED_SPIDER_ROOT', red_spider_root, 'o')
    os.chdir(red_spider_root)
    # existence of the build dir is the natural indicator of a previous install
    user_pref = raw_input(
        reinstall_choice_msg if so.path.exists(build_dir) else new_install_choice_msg
    )
    if 'y' in user_pref or 'Y' in user_pref:
        # invariant: RED_SPIDER_ROOT is the working directory and is read/writeable
        if not so.path.exists(src_dir):
            print(no_src_panic_msg)
            sys.exit(1)
        fname = 'rsshell.py'
        src_file = os.path.join(src_dir, fname)
        if not so.path.exists(src_file):
            print(no_rsshell_warning_msg.format(os.path.join('src', fname)))
            return
        if os.name != 'nt':  # POSIX assumed
            fname = os.path.splitext(fname)[0]
        if not so.path.exists(extbin_dir):
            os.mkdir(extbin_dir)
            # assumption: if it doesn't exist it also isn't in the PATH
            extend_user_env('PATH', os.path.abspath(extbin_dir), 'a')
        bin_file = os.path.join(extbin_dir, fname)
        shutil.copy2(src_file, bin_file)
        if os.name == 'nt' and '.py' not in os.getenv('PATHEXT'):
            fwd = open(os.path.splitext(bin_file)[0] + '.cmd', 'w')
            fwd.write(windows_rsshell_forward_script.format(os.path.abspath(bin_file)))
            fwd.close()
        print(rsshell_install_success_msg.format(bin_file))
        for dir in (bin_dir, lib_dir, build_dir, cfg_dir, work_dir):
            if not so.path.exists(dir):
                os.mkdir(dir)
        docfile = open('config/doc.txt', 'w')
        for cmd in documented_cmds:
            docfile.write(cmd[0] + " " + cmd[1] + "\n")
        # Installing from within Python works fine as long as we only need to copy
        # some files, but this will become unmanageable if we also have to compile
        # C++, Haskell, etcetera.
        # So in the future the part below should be taken care of by some external
        # build tool, called from here.
        print(install_patience_msg)
        if os.name == 'nt':  # Windows
            # if the program reaches this point, src_dir and bin_dir exist for sure
            for src_name, bin_name in zip(executable_scripts, executable_scripts):
                src_file = os.path.join(src_dir, src_name)
                if not so.path.exists(src_file):
                    print(script_not_found_msg.format(src_name))
                else:
                    bin_file = os.path.join(bin_dir, bin_name)
                    shutil.copy2(src_file, bin_file)
                    if not os.access(bin_file, os.X_OK):
                        from stat import *
                        os.chmod(bin_file,  S_IRUSR | S_IWUSR | S_IXUSR |
                                            S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH )
        else:                # POSIX assumed
            # if the program reaches this point, src_dir and bin_dir exist for sure
            for src_name, bin_name in zip(executable_scripts, map(lambda x: os.path.splitext(x)[0], executable_scripts)):
                src_file = os.path.join(src_dir, src_name)
                if not so.path.exists(src_file):
                    print(script_not_found_msg.format(src_name))
                else:
                    bin_file = os.path.join(bin_dir, bin_name)
                    shutil.copy2(src_file, bin_file)
                    if not os.access(bin_file, os.X_OK):
                        from stat import *
                        os.chmod(bin_file,  S_IRUSR | S_IWUSR | S_IXUSR |
                                            S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH )
        # if the program reaches this point, lib_dir exists for sure
        # ideally the modules in lib should be optimized, but we can fix that later
        for module in python_modules:
            dir, module_name = module.os.path.split('/')
            source_file = os.path.join(dir, module_name)
            # note: on Windows, os.path.join(dir, module_name) != module
            if not so.path.exists(source_file):
                print(script_not_found_msg.format(source_file))
            else:
                target_file = os.path.join(lib_dir, module_name + 'c')
                py_compile.compile(source_file, target_file)
        # add more of such steps if that's feasible and no build system is available
    print(farewell_msg)
